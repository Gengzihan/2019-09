<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    var ary = [100, 200];//字面量的创建方式
    var ary2 = new Array(100, 200);//通过构造函数模式创建；
    ary.push(1, 2, 3);
    ary2.push(4, 5, 6);
    console.log(ary, ary2)
    //Array 数组类  ary2 ary都是Array的实例
    var Person = function (name, age) {
        this.name = name;
        this.age = age;
        this.eat = function () {
            console.log(`${this.name}吃饭`)
        }
    }
    Person.prototype.play = function () {
        //在  Person类的原型上 添加一个 play属性，值是一个函数
        console.log('玩耍')
    }


    var per1 = new Person('李四', 20)//per1 是 Person类的一个实例：person是一个自定义类
    var per2 = new Person('张三', 22);
    console.log(per1, per2)
    console.log(per1.eat === per2.eat)//false
    console.log(ary.push === ary2.push)//true
    console.log(per1.play === per2.play) //true
    console.log(per1.play)//per1 是怎么调到的 play 函数

    console.log(per1.__proto__ === Person.prototype)// true  因为他带这一个实例的属性
    /*
       原型： prototype  就是一块堆内存
       每一个实例(对象) 都有一个 __proto__的属性，指向所属类的原型
       每一个函数(类)  都有一个 prototype的属性， 指向自已的原理
       每一个类的原型上都有一个 constructor属性，指向所有类(函数) 本身
        */


    /*
    作用域链  变量的查找机制，先看变量是不是自已私有的 不是的话就去上级作用域查找
    原型链    是属性的查找机制，先在自已身上查找，没有的话就通过 __proto__向自已所属类的原型上查找
     */




</script>