<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /*
       类          实例           原型对象 (一些共用的属性)
       人类       特朗普            公用属性

       JS天生自带的类： Function  Array     Object(基类)  String....
       自定义类： function   Tab(){}

       自带类的原型上的属性可以修改  但是不可以覆盖；

       prototype  __proto__  constructor  天生自带的属性、

       //原型就是一个堆内存(对象)
       每一个函数都 天生自带一个  prototype  的属性，指向自已的原型
       每一个对象(实例) 都天生自带一个 __proto__的属性，指向所属类的原型
       每一个默认的原型上都有一个  constructor 属性，指向 构造函数本身


        作用域链:是变量的查找机制
       原型链： 属性的查找机制，现在自已身上查找，没有的话就通过 __proto__接着向上级原型查找， 在没有  接着 通过__proto__向上级原型查找，直到找到   基类的原型
       在没有的话，拿到的就是undefined

       //查看一个属性是否是私有的   per1.hasOwnPrototype('eat')
       //封装一个判断共有属性的方法，这个方法需要放在基类的属性上，需要注意首先是它的属性，然后还不能是私有属性；
       //在原型封装的方法   里边的this 需要保证的是 该类的实例

       //'eat' in per1  per1能否调用到 eat 属性，
     */
    Object.prototype.eat = function () {
        //this
    }
    var a = [];
    console.log(a.eat)
    console.log('eat' in a)


    Number.prototype.plus = function () {
        return this + a
    }
    Number.prototypr.minus = function () {
        return this - a
    }
    var n = 20;
    var m = n.plus(10).minus(5);
    console.log(m);//=>20+20-5    35


    //练习
    function C1(name) {
        if (name) {
            this.name = name;
        }
    }
    function C2(name) {
        this.name = name;
    }
    function C3(name) {
        this.name = name || 'join';
    }
    C1.prototype.name = 'Tom';
    C2.prototype.name = 'Tom';
    C3.prototype.name = 'Tom';
    alert((new C1().name) + (new C2().name) + (new C3().name));

</script>